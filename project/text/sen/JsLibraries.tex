\subsubsection{Бібліотеки JS}

\paragraph{Express}

При розробці використано бібліотеку Express — гнучкий фреймворк для веб-застосунків, побудованих на Node.js, що надає широкий набір функціональності, полегшуючи створення надійних API.

Express забезпечує тонкий прошарок базової функціональності для веб-застосунків, що не спотворює звичну та зручну функціональність Node.js., при отриманні запиту він оброблюватиметься відповідно до визначення маршруту (рис.~\ref{fig:Route}), де app є екземпляром express, METHOD є методом HTTP-запиту, PATH є шляхом на сервері, HANDLER є функцією-обробником, що спрацьовує, коли даний маршрут затверджено як співпадаючий \cite{hahn2016express}.

Маршрутизація визначає, як додаток відповідає на клієнтський запит до конкретної адреси (кінцевій точці), яким є URI (або шлях), і певного методу запиту HTTP (GET, POST і т.д.).

Кожен маршрут може мати одну або кілька функцій обробки, які виконуються при зіставленні маршруту.

Express підтримує перераховані далі методи маршрутизації, які відповідають методам HTTP: get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m -search, notify, subscribe, unsubscribe, patch, search і connect.

Шляхи маршрутів, в поєднанні з методом запиту, визначають конкретні адреси (кінцеві точки), в яких можуть бути створені запити. Шляхи маршрутів можуть являти собою рядки, шаблони рядків або регулярні вирази.

Для обробки запиту можна вказати кілька функцій зворотного виклику, подібних middleware (детальніше про них в пункті~\ref{subs:middleware}). Єдиним винятком є те, що ці зворотні виклики можуть ініціювати next ('route') для обходу інших зворотних викликів маршруту. За допомогою цього механізму можна включити в маршрут попередні умови, а потім передати управління подальшим маршрутами, якщо продовжувати роботу з поточним маршрутом не потрібно.

В Express немає засобів для роботи з базою даних \cite{simon2015nodeexpress}. Їх надають модулі та бібліотеки Node.js, що дозволяють взаємодіяти з будь-якою базою даних. В роботі використовується ORM Sequalize (детальніше в пункті \ref{subs:orm})


\paragraph{JSON Web Token}

Для забезпечення конфіденційності при обміні даними використовується JSON Web Token. Деталі роботи з ним розглянуто в розділі \ref{subsubsection:jwt}. Для роботи з JSON Web Token використовується бібліотека jsonwebtoken.

JWT визначає особливу структуру інформації, яка відправляється по мережі. Вона представлена в двох формах - серіалізовані і десеріалізованной. Перша використовується безпосередньо для передачі даних із запитами і відповідями. З іншого боку, щоб читати і записувати інформацію в токен, потрібна його десеріалізація.



\paragraph{bcrypt.js}

Оптимізовано bcrypt в JavaScript з нульовими залежностями. Сумісний з C ++ bcrypt прив'язка на node.js і також працює в браузері.

Міркування безпеки
Крім включення солі для захисту від атак аеродинамічних таблиць, bcrypt є адаптивною функцією: з плином часу кількість ітерацій може бути збільшена, щоб зробити її більш повільною, тому вона залишається стійкою до атаки з використанням грубої сили навіть при збільшенні потужності обчислення. (подивитися)

Хоча bcrypt.js є сумісним з C ++ bcrypt прив'язка, він написаний на чистому JavaScript і, таким чином, повільніше (близько 30\%), ефективно зменшуючи кількість ітерацій, які можуть бути оброблені в рівний проміжок часу.

Максимальна вхідна довжина становить 72 байти (зауважимо, що символи UTF8 кодуються до 4 байт), а довжина згенерованих хешей - 60 символів.
