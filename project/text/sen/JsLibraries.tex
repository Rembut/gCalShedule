\subsubsection{Бібліотеки JS}

\paragraph{Express} \label{par:Express}

При розробці використано бібліотеку Express — гнучкий фреймворк для веб-застосунків, побудованих на Node.js, що надає широкий набір функціональності, полегшуючи створення надійних API.

Express забезпечує тонкий прошарок базової функціональності для веб-застосунків, що не спотворює звичну та зручну функціональність Node.js., при отриманні запиту він оброблюватиметься відповідно до визначення маршруту (рис.~\ref{fig:Route}), де app є екземпляром express, METHOD є методом HTTP-запиту, PATH є шляхом на сервері, HANDLER є функцією-обробником, що спрацьовує, коли даний маршрут затверджено як співпадаючий \cite{hahn2016express}.

Маршрутизація визначає, як додаток відповідає на клієнтський запит до конкретної адреси (кінцевій точці), яким є URL (або шлях), і певного методу запиту HTTP (GET, POST і т.д.).

Кожен маршрут може мати одну або кілька функцій обробки, які виконуються при зіставленні маршруту.

Express підтримує перераховані далі методи маршрутизації, які відповідають методам HTTP: get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m -search, notify, subscribe, unsubscribe, patch, search і connect.

Шляхи маршрутів, в поєднанні з методом запиту, визначають конкретні адреси (кінцеві точки), в яких можуть бути створені запити. Шляхи маршрутів можуть являти собою рядки, шаблони рядків або регулярні вирази (рис.~\ref{fig:httpSampleExpress}).

\addCodeAsImg{\lstinputlisting[numbers=left]{code/ExpressHttpServer.tex}}{Приклад HTTP серверу}{fig:httpSampleExpress}

Для обробки запиту можна вказати кілька функцій зворотного виклику, подібних middleware (детальніше про них в пункті~\ref{subs:middleware}). Єдиним винятком є те, що ці зворотні виклики можуть ініціювати next ('route') для обходу інших зворотних викликів маршруту. За допомогою цього механізму можна включити в маршрут попередні умови, а потім передати управління подальшим маршрутами, якщо продовжувати роботу з поточним маршрутом не потрібно.

В Express немає засобів для роботи з базою даних \cite{simon2015nodeexpress}. Їх надають модулі та бібліотеки Node.js, що дозволяють взаємодіяти з будь-якою базою даних. В роботі використовується ORM Sequalize (детальніше в пункті \ref{subs:orm})


\paragraph{JSON Web Token}

Для забезпечення конфіденційності при обміні даними використовується JSON Web Token. Деталі роботи з ним розглянуто в розділі \ref{subsubsection:jwt}. Для роботи з JSON Web Token використовується бібліотека jsonwebtoken.

JWT визначає особливу структуру інформації, яка відправляється по мережі. Вона представлена в двох формах - серіалізованій і десеріалізованній. Перша використовується безпосередньо для передачі даних із запитами і відповідями. З іншого боку, щоб читати і записувати інформацію в токен, потрібна його десеріалізація.

У несеріалізованном вигляді JWT складається з заголовка і корисного навантаження, які є звичайними JSON-об'єктами. 

Заголовок \cite{jose} в основному використовується для опису криптографічних функцій, які застосовуються для підпису та / або шифрування токена. Тут також можна вказати додаткові властивості, наприклад, тип вмісту, хоча це рідко потрібно. Щоб дізнатися більше про заявках заголовка, зверніться до специфікації.

Якщо JWT підписаний і / або зашифрований, в заголовку вказується ім'я алгоритму шифрування. Для цього призначена заявка alg: 

\addCodeAsImg{\lstinputlisting[numbers=left]{code/JWT1.tex}}{Заявка alg у визначенні JWT}{fig:JsonAlg}

Слово «заявка» в специфікації позначає просто частина інформації і аналогічна ключу JSON-об'єкта. Вона представлена у вигляді пари ім'я: значення, де ім'я завжди є рядком. Значенням заявки може бути будь-який серіалізований тип даних. Наприклад, об'єкт JSON на рис.~\ref{fig:JsonSample2} складається з трьох заявок: $iss$, $exp$ і $http://example.com/is\_root$.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/JWT2.tex}}{Приклад об'єкту JSON}{fig:JsonSample2}

Заявки бувають службовими і призначеними для користувача. Перші зазвичай є частиною будь-якого стандарту, наприклад, реєстру JSON Web Token Claims, і мають певні значення. 

Найбільш поширені службові заявки:
\begin{enumerate}
	\item iss - видавець токена;
	\item sub - описуваний об'єкт;
	\item aud - одержувачі;
	\item exp - дата закінчення терміну дії;
	\item iat - час створення.
\end{enumerate}

Заголовок описує криптографічні операції, які застосовуються до веб-токен. Але в деяких випадках підпис і шифрування можуть бути відсутні. Зазвичай це відбувається, коли JWT є частиною деякої вже зашифрованою структури даних. У заголовку такого непідписаного токена заявка alg повинна бути дорівнює $none$~(рис.~\ref{fig:JsonNone}).

\addCodeAsImg{\lstinputlisting[numbers=left]{code/JWT3.tex}}{Приклад непідписаного токену JSON}{fig:JsonNone}

Корисні дані - частина токена, в якій розміщується вся необхідна інформація користувача. Як і заголовок, корисне навантаження являє собою звичайний об'єкт JSON. Тут жодне поле не є обов'язковим. Зазвичай використовуються вже розглянуті службові заявки iss, sub і aud, а також специфічні для додатка дані. Наприклад JWT у фреймворку OpenID виглядає як зображено на рис.~\ref{fig:JsonOpenID}.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/JWT4.tex}}{Приклад об'єкту JSON у фреймворку OpenID}{fig:JsonOpenID}

JSON web token в серіалізованій формі -- це рядок такого формату:

$$[Header].[Payload].[Signature]$$

Тема (header) і корисне навантаження (payload) присутні завжди, а ось підпис (signature) може бути відсутнім (рис.~\ref{fig:CompactJwt}).

\addCodeAsImg{\lstinputlisting[numbers=left]{code/CompactJwt.tex}}{Компактна форма JWT}{fig:CompactJwt}

Вона отримана з даних, наведених на рис.~\ref{fig:JsonEmptySignature}.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/JWT5.tex}}{Приклад об'єкту JSON з пустим підписом}{fig:JsonEmptySignature}

Тут визначено непідписаний токен, його заявка alg дорівнює none. Тому в рядку немає третьої частини, однак точка після другого фрагмента все одно додається.

Процес серіалізації JWT складається з кодування заголовка, корисного навантаження та підписи, якщо вона є, за допомогою алгоритму base64url. Це проста варіація base64, яка використовує URL-безпечний символ <<\_>> замість небезпечних <<+>> і <</>>. Справа в тому, що деякі інструменти обробки даних розпізнають керуючі символи в рядку, тому їх бути не повинно. Дізнатися більше про base64 можна тут.

На рис.~\ref{fig:JsonSerialize} зображений процес серіалізації непідписаного токена.

\addimg{JsonSerialize.png}{1}{Процес серіалізації непідписаного токена}{fig:JsonSerialize}

\paragraph{bcrypt.js}

Оптимізовано bcrypt в JavaScript з нульовими залежностями. Сумісний з C ++ bcrypt прив'язка на node.js і також працює в браузері.

Міркування безпеки
Крім включення солі для захисту від атак аеродинамічних таблиць, bcrypt є адаптивною функцією: з плином часу кількість ітерацій може бути збільшена, щоб зробити її більш повільною, тому вона залишається стійкою до атаки з використанням грубої сили навіть при збільшенні потужності обчислення. (подивитися)

Хоча bcrypt.js є сумісним з C++, він написаний на чистому JavaScript і, таким чином, повільніше (близько 30\%), ефективно зменшуючи кількість ітерацій, які можуть бути оброблені в рівний проміжок часу.

Максимальна вхідна довжина становить 72 байти (зауважимо, що символи UTF8 кодуються до 4 байт~\cite{yergeau2003utf}), а довжина згенерованих хешей - 60 символів.
