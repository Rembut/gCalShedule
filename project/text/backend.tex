\section{ПРОЕКТУВАННЯ BACK-END ЧАСТИНИ}
\subsection{Клієнт-серверна архітектура веб-додатків}
Архітектура клієнт-сервер є одним із архітектурних шаблонів програмного забезпечення та є домінуючою концепцією у створенні розподілених мережних застосунків і передбачає взаємодію та обмін даними між ними. Вона передбачає такі основні компоненти:
\begin{itemize}
	\item набір серверів, які надають інформацію або інші послуги програмам, які звертаються до них;
	\item набір клієнтів, які використовують сервіси, що надаються серверами;
	\item мережа, яка забезпечує взаємодію між клієнтами та серверами.
\end{itemize}

Сервери є незалежними один від одного. Клієнти також функціонують паралельно і незалежно один від одного. Немає жорсткої прив'язки клієнтів до серверів. Більш ніж типовою є ситуація, коли один сервер одночасно обробляє запити від різних клієнтів; з іншого боку, клієнт може звертатися то до одного сервера, то до іншого. Клієнти мають знати про доступні сервери, але можуть не мати жодного уявлення про існування інших клієнтів.

Загальноприйнятим є положення, що клієнти та сервери — це перш за все програмні модулі. Найчастіше вони знаходяться на різних комп'ютерах, але бувають ситуації, коли обидві програми — і клієнтська, і серверна, фізично розміщуються на одній машині; в такій ситуації сервер часто називається локальним.

\subsubsection{Мікросервісна архітектура}
Мікросервісна архітектура полягає в створенні для кожного з логічно відокремлених компонентів системи окремого модулю, пов'язаного з рештою.

Один з принципів проектування мікросервісних додатків додатків визначає, що розмір одного сервісу повинен бути таким, щоб повністю «вміщуватися» в голову програміста.

В рамках системи закладено низку модулів, частина з яких використовує у своїй роботі доступ до сервісів Google, зокрема Google Sheets та Google Calendar. При цьому для взаємодії посередництвом Google API потрібно пройти процедуру аутентифікації (рис. 3.1), закладену в методи бібліотек для основних платформ, в тому числі Node.js. Всі пакети мають відкритий вихідний код та поширюються разом з документацією.

%TODO uml

\subsection{API веб-додатку}
Прикладний програмний інтерфейс — набір визначень підпрограм, протоколів взаємодії та засобів для створення програмного забезпечення. Спрощено - це набір чітко визначених методів для взаємодії різних компонентів. API надає розробнику засоби для швидкої розробки програмного забезпечення. API може бути для веб-базованих систем, операційних систем, баз даних, апаратного забезпечення, програмних бібліотек тощо.

\subsubsection{REST API}
REST — підхід до архітектури мережевих протоколів, які забезпечують доступ до інформаційних ресурсів. Був описаний і популяризований 2000 року Роєм Філдінгом, одним із творців протоколу HTTP. В основі REST закладено принципи функціонування Всесвітньої павутини і, зокрема, можливості HTTP. Філдінг розробив REST паралельно з HTTP 1.1 базуючись на попередньому протоколі HTTP 1.0.

Дані повинні передаватися у вигляді невеликої кількості стандартних форматів (наприклад, HTML, XML, JSON). Будь-який REST протокол (HTTP в тому числі) повинен підтримувати кешування, не повинен залежати від мережевого прошарку, не повинен зберігати інформації про стан між парами «запит-відповідь». Стверджується, що такий підхід забезпечує масштабовність системи і дозволяє їй еволюціонувати з новими вимогами.

REST, як і кожен архітектурний стиль відповідає ряду архітектурних обмежень (англ. architectural constraints). Це гібридний стиль який успадковує обмеження з інших архітектурних стилів.[1]

\paragraph{Клієнт-сервер}
Перша архітектура від якої він успадковує обмеження — це клієнт-серверна архітектура. Її обмеження вимагає розділення відповідальності між компонентами, які займаються зберіганням та оновленням даних (сервером), і тими компонентами, які займаються відображенням даних на інтерфейсі користувача та реагування на дії з цим інтерфейсом (клієнтом). Таке розділення дозволяє компонентам еволюціонувати незалежно.

\paragraph{Відсутність стану}
Наступним обмеженням є те, що взаємодії між сервером та клієнтом не мають стану, тобто кожен запит містить всю необхідну інформацію для його обробки, і не покладається на те, що сервер знає щось з попереднього запиту.

Відсутність стану не означає що стану немає. Відсутність стану означає, що сервер не знає про стан клієнта. Коли клієнт, наприклад, запитує головну сторінку сайту, сервер відповідає на запитання і забуває про клієнта. Клієнт може залишити сторінку відкритою протягом кількох років, перш ніж натиснути посилання, і тоді сервер відповість на інший запит. Тим часом сервер може відповідати на запити інших клієнтів, або нічого не робити — для клієнта це не має значення.

Таким чином, наприклад дані про стан сесії (користувача, який автентифікувався) зберігаються на клієнті, і передаються з кожним запитом. Це покращує масштабовність, бо сервер після закінчення обробки запиту може звільнити всі ресурси, задіяні для цієї операції, без жодного ризику втратити цінну інформацію. Також спрощується моніторинг і зневадження, бо для того аби розібратись, що відбувається в певному запиті, досить подивитись лише на той один запит. Збільшується надійність, бо помилка в одному запиті не зачіпає інші.

\subsubsection{SOAP API}
SOAP — протокол обміну структурованими повідомленнями в розподілених обчислювальних системах, базується на форматі XML.

Спочатку SOAP призначався, в основному, для реалізації віддаленого виклику процедур (RPC), а назва була абревіатурою: Simple Object Access Protocol — простий протокол доступу до об'єктів. Зараз протокол використовується для обміну повідомленнями в форматі XML, а не тільки для виклику процедур. SOAP є розширенням мови XML-RPC.

SOAP можна використовувати з будь-яким протоколом прикладного рівня: SMTP, FTP, HTTP та інші. Проте його взаємодія з кожним із цих протоколів має свої особливості, які потрібно відзначити окремо. Найчастіше SOAP використовується разом з HTTP.

SOAP є одним зі стандартів, на яких ґрунтується технологія веб-сервісів.

\subsubsection{JSON Web Token}
Для забезпечення конфіденційності при обміні даними використовується JSON Web Token. Роути, що обробляють реєстраційні та авторизаційні запити, представлено на рис. 3.3.
JSON Web Token це стандарт токена доступу на основі JSON, стандартизованого в RFC 7519. Використовується для верифікації тверджень. JSON Web Token складається з трьох частин: заголовка, вмісту і підпису.

В корисному навантаженні зберігається будь-яка інформація, яку потрібно перевірити. Кожен ключ в корисному навантаженні відомий як «заява». Як і заголовок, корисне навантаження кодується в base64. Після отримання заголовку і корисного навантаження, обчислюється підпис.

\subsection{Проектування та прототипування back-end частини}
Для обміну інформацією між користувацьким додатком та back-end частиною використовується протокол передачі гіпертекстових даних HTTP. Передачу даних забезпечує стек транспортних протоколів TCP/IP.
Одним з способів побудови мереживих HTTP-додатків є використання  асинхронного подієвого JavaScript–оточення Node. Для кожного з’єднання викликається функція зворотнього виклику, проте коли з’єднань немає Node засинає.

У Node не має функцій, що працюють напряму з I/O, тому процес не блокується ніколи. Як результат, на Node легко розробляти масштабовані системи [7].
Node широко використовує подієву модель, він приймає цикл подій за основу оточення, замість того, щоб використовувати його в якості бібліотеки. В інших системах відбувається блокування виклику для запуску циклу подій.

При розробці використано бібліотеку Express — гнучкий фреймворк для веб-застосунків, побудованих на Node.js, що надає широкий набір функціональності, полегшуючи створення надійних API.
Express забезпечує тонкий прошарок базової функціональності для веб-застосунків, що не спотворює звичну та зручну функціональність Node.js., при отриманні запиту він оброблюватиметься відповідно до визначення маршруту (рис. 3.2), де app є екземпляром express, METHOD є методом HTTP-запиту, PATH є шляхом на сервері, HANDLER є функцією-обробником, що спрацьовує, коли даний маршрут затверджено як співпадаючий.

%TODO code

\subsubsection{Роути}
В процесі роботи використовується протокол прикладного рівня HTTP. Обмін повідомленнями йде за схемою «запит-відповідь». Для ідентифікації ресурсів HTTP використовує URI. 

В додатку обробляються основні  HTTP методи для взаємодії об’єктами (рис. 3.3). 

%TODO UML

Протокол HTTP не зберігає свого стану між парами «запит-відповідь». Компоненти, що використовують HTTP, можуть самостійно здійснювати збереження інформації про стан, пов'язаний з останніми запитами та відповідями. 

Одним з розповсюджених способів реалізації цього можна назвати так звані cookies — невеликі записи, що зберігаються браузером. Зазвичай, вони встановлюються при виконанні користувачем певних дій та надсилаються серверу разом з наступними запитами. 

На рис. 3.4 зображено процес створення адміністратором нового користувача системи. Ця функція може викликатися після відповідного запиту з компоненту веб-додатку, котрий детально описано в пункті 4.3.3.

Після отримання зазначеного POST запиту, сервер перевірить, чи має користувач відповідні права (блок Auth рис. 3.7), створить об’єкт користувача з відповідними правами та збереже його в базі даних.

Створений користувач може входити до системи (рис. ХХ) для виконання певних задач з користування системою.

Можна зазначити, що адміністратор теж є користувачем, проте з особливими правами (диференціація на рис. 3.3).

%TODO UML

\subsubsection{Моделі}
В процесі проектування закладено серію моделей, що відповідають об’єктам предметної області. В рамках системи зберігаються в базі даних у вигляді таблиць з певними взаємозвязками (реляційну модель описано в підрозділі 2.2). Для доступу до даних використовуються основні HTTP методи, що відповідають операціям CRUD, їх перелічено нижче.

\clearpage