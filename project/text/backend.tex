\section{ПРОЕКТУВАННЯ BACK-END ЧАСТИНИ}

\subsection{Клієнт-серверна архітектура веб-додатків}

Архітектура клієнт-сервер є одним із архітектурних шаблонів програмного забезпечення та є домінуючою концепцією у створенні розподілених мережних застосунків і передбачає взаємодію та обмін даними між ними. Вона передбачає такі основні компоненти:
\begin{itemize}
	\item набір серверів, які надають інформацію або інші послуги програмам, які звертаються до них;
	\item набір клієнтів, які використовують сервіси, що надаються серверами;
	\item мережа, яка забезпечує взаємодію між клієнтами та серверами.
\end{itemize}

Сервери є незалежними один від одного. Клієнти також функціонують паралельно і незалежно один від одного. Немає жорсткої прив'язки клієнтів до серверів. Більш ніж типовою є ситуація, коли один сервер одночасно обробляє запити від різних клієнтів; з іншого боку, клієнт може звертатися то до одного сервера, то до іншого. Клієнти мають знати про доступні сервери, але можуть не мати жодного уявлення про існування інших клієнтів.

Загальноприйнятим є положення, що клієнти та сервери — це перш за все програмні модулі. Найчастіше вони знаходяться на різних комп'ютерах, але бувають ситуації, коли обидві програми — і клієнтська, і серверна, фізично розміщуються на одній машині; в такій ситуації сервер часто називається локальним.

\subsubsection{Мікросервісна архітектура}

Мікросервісна архітектура полягає в створенні для кожного з логічно відокремлених компонентів системи окремого модулю, пов'язаного з рештою.

Один з принципів проектування мікросервісних додатків додатків визначає, що розмір одного сервісу повинен бути таким, щоб повністю «вміщуватися» в голову програміста.

\addCodeAsImg{\input{uml/GoogleServicesAuth}}{Авторизація з сервісами Google}{fig:GoogleServicesAuth}

В рамках системи закладено низку модулів, частина з яких використовує у своїй роботі доступ до сервісів Google, зокрема Google Sheets та Google Calendar. При цьому для взаємодії посередництвом Google API потрібно пройти процедуру аутентифікації (рис.~\ref{fig:GoogleServicesAuth}), закладену в методи бібліотек для основних платформ, в тому числі Node.js. Всі пакети мають відкритий вихідний код та поширюються разом з документацією.

\subsection{API веб-додатку}

Прикладний програмний інтерфейс — набір визначень підпрограм, протоколів взаємодії та засобів для створення програмного забезпечення. Спрощено - це набір чітко визначених методів для взаємодії різних компонентів. API надає розробнику засоби для швидкої розробки програмного забезпечення. API може бути для веб-базованих систем, операційних систем, баз даних, апаратного забезпечення, програмних бібліотек тощо.

\subsubsection{REST API}

REST — підхід до архітектури мережевих протоколів, які забезпечують доступ до інформаційних ресурсів. Був описаний і популяризований 2000 року Роєм Філдінгом, одним із творців протоколу HTTP. В основі REST закладено принципи функціонування Всесвітньої павутини і, зокрема, можливості HTTP. Філдінг розробив REST паралельно з HTTP 1.1 базуючись на попередньому протоколі HTTP 1.0.

Дані повинні передаватися у вигляді невеликої кількості стандартних форматів (наприклад, HTML, XML, JSON). Будь-який REST протокол (HTTP в тому числі) повинен підтримувати кешування, не повинен залежати від мережевого прошарку, не повинен зберігати інформації про стан між парами «запит-відповідь». Стверджується, що такий підхід забезпечує масштабовність системи і дозволяє їй еволюціонувати з новими вимогами.

REST, як і кожен архітектурний стиль відповідає ряду архітектурних обмежень (англ. architectural constraints). Це гібридний стиль який успадковує обмеження з інших архітектурних стилів.

\paragraph{Клієнт-сервер}

Перша архітектура від якої він успадковує обмеження — це клієнт-серверна архітектура. Її обмеження вимагає розділення відповідальності між компонентами, які займаються зберіганням та оновленням даних (сервером), і тими компонентами, які займаються відображенням даних на інтерфейсі користувача та реагування на дії з цим інтерфейсом (клієнтом). Таке розділення дозволяє компонентам еволюціонувати незалежно.

\paragraph{Відсутність стану}

Наступним обмеженням є те, що взаємодії між сервером та клієнтом не мають стану, тобто кожен запит містить всю необхідну інформацію для його обробки, і не покладається на те, що сервер знає щось з попереднього запиту.

Відсутність стану не означає що стану немає. Відсутність стану означає, що сервер не знає про стан клієнта. Коли клієнт, наприклад, запитує головну сторінку сайту, сервер відповідає на запитання і забуває про клієнта. Клієнт може залишити сторінку відкритою протягом кількох років, перш ніж натиснути посилання, і тоді сервер відповість на інший запит. Тим часом сервер може відповідати на запити інших клієнтів, або нічого не робити — для клієнта це не має значення.

Таким чином, наприклад дані про стан сесії (користувача, який автентифікувався) зберігаються на клієнті, і передаються з кожним запитом. Це покращує масштабовність, бо сервер після закінчення обробки запиту може звільнити всі ресурси, задіяні для цієї операції, без жодного ризику втратити цінну інформацію. Також спрощується моніторинг і зневадження, бо для того аби розібратись, що відбувається в певному запиті, досить подивитись лише на той один запит. Збільшується надійність, бо помилка в одному запиті не зачіпає інші.

\subsubsection{SOAP API}

SOAP — протокол обміну структурованими повідомленнями в розподілених обчислювальних системах, базується на форматі XML.

Спочатку SOAP призначався, в основному, для реалізації віддаленого виклику процедур (RPC), а назва була абревіатурою: Simple Object Access Protocol — простий протокол доступу до об'єктів. Зараз протокол використовується для обміну повідомленнями в форматі XML, а не тільки для виклику процедур. SOAP є розширенням мови XML-RPC.

SOAP можна використовувати з будь-яким протоколом прикладного рівня: SMTP, FTP, HTTP та інші. Проте його взаємодія з кожним із цих протоколів має свої особливості, які потрібно відзначити окремо. Найчастіше SOAP використовується разом з HTTP.

SOAP є одним зі стандартів, на яких ґрунтується технологія веб-сервісів.

\subsubsection{JSON Web Token} \label{subsubsection:jwt}

\addCodeAsImg{\input{uml/ApiAccess}}{Доступ на виконання запитів до системи}{fig:ApiAccess}

Для забезпечення конфіденційності при обміні даними використовується JSON Web Token. Роути, що обробляють реєстраційні та авторизаційні запити, представлено на рис.~\ref{fig:ApiAccess}.

JSON Web Token це стандарт токена доступу на основі JSON, стандартизованого в RFC 7519. Використовується для верифікації тверджень. JSON Web Token складається з трьох частин: заголовка, вмісту і підпису.

В корисному навантаженні зберігається будь-яка інформація, яку потрібно перевірити. Кожен ключ в корисному навантаженні відомий як «заява». Як і заголовок, корисне навантаження кодується в base64. Після отримання заголовку і корисного навантаження, обчислюється підпис.

\subsection{Проектування та прототипування back-end частини}

Для обміну інформацією між користувацьким додатком та back-end частиною використовується протокол передачі гіпертекстових даних HTTP. Передачу даних забезпечує стек транспортних протоколів TCP/IP.
Одним з способів побудови мереживих HTTP-додатків є використання  асинхронного подієвого JavaScript–оточення Node. Для кожного з’єднання викликається функція зворотнього виклику, проте коли з’єднань немає Node засинає.

У Node не має функцій, що працюють напряму з I/O, тому процес не блокується ніколи. Як результат, на Node легко розробляти масштабовані системи \cite{zeiss2015node}.
Node широко використовує подієву модель, він приймає цикл подій за основу оточення, замість того, щоб використовувати його в якості бібліотеки. В інших системах відбувається блокування виклику для запуску циклу подій.

При розробці використано бібліотеку Express — гнучкий фреймворк для веб-застосунків, побудованих на Node.js, що надає широкий набір функціональності, полегшуючи створення надійних API.

Express забезпечує тонкий прошарок базової функціональності для веб-застосунків, що не спотворює звичну та зручну функціональність Node.js., при отриманні запиту він оброблюватиметься відповідно до визначення маршруту (рис.~\ref{fig:Route}), де app є екземпляром express, METHOD є методом HTTP-запиту, PATH є шляхом на сервері, HANDLER є функцією-обробником, що спрацьовує, коли даний маршрут затверджено як співпадаючий.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/AppMethod.js}}{Структура визначення маршрутів}{fig:Route}

\subsubsection{Роути}

В процесі роботи використовується протокол прикладного рівня HTTP. Обмін повідомленнями йде за схемою «запит-відповідь». Для ідентифікації ресурсів HTTP використовує URI. 

В додатку обробляються основні  HTTP методи для взаємодії об’єктами (рис.~\ref{fig:ApiAccess}). 

Протокол HTTP не зберігає свого стану між парами «запит-відповідь». Компоненти, що використовують HTTP, можуть самостійно здійснювати збереження інформації про стан, пов'язаний з останніми запитами та відповідями. 

Одним з розповсюджених способів реалізації цього можна назвати так звані cookies — невеликі записи, що зберігаються браузером. Зазвичай, вони встановлюються при виконанні користувачем певних дій та надсилаються серверу разом з наступними запитами. 

На рис.~\ref{fig:AppSignUp} зображено процес створення адміністратором нового користувача системи.

\addCodeAsImg{\input{uml/AppSignUp}}{Процес створення адміністратором нового користувача системи}{fig:AppSignUp}

Після отримання зазначеного POST запиту, сервер перевірить, чи має користувач відповідні права (блок Auth рис.~\ref{fig:CreateOperation}), створить об’єкт користувача з відповідними правами та збереже його в базі даних.

Створений користувач може входити до системи (рис.~\ref{fig:AppSignIn}) для виконання певних задач з користування системою.

\addCodeAsImg{\input{uml/AppSignIn}}{Вхід користувача до системи}{fig:AppSignIn}

Можна зазначити, що адміністратор теж є користувачем, проте з особливими правами (диференціація на рис.~\ref{fig:Route}).

\subsubsection{Моделі}

В процесі проектування закладено серію моделей, що відповідають об’єктам предметної області. В рамках системи зберігаються в базі даних у вигляді таблиць з певними взаємозвязками (реляційну модель описано в підрозділі \ref{subsection:relationModel}). Для доступу до даних використовуються основні HTTP методи, що відповідають операціям CRUD (від Create, Read, Update, Delete), їх перелічено нижче.

\paragraph{GET}
\addCodeAsImg{\input{uml/ReadOperation}}{Виконання запиту на отримання об’єкта}{fig:ReadOperation}

Запитує вміст вказаного ресурсу, який може приймати параметри, що передаються в URI (рис.~\ref{fig:ReadOperation}). Згідно зі стандартом, ці запити є ідемпотентними — багатократне повторення одного і того ж запиту GET приводить до однакових результатів (за умови, що сам ресурс не змінився за час між запитами).

В запропонованій реалізації запит GET має дві версії — з параметром (ID) та без нього. Останній виконує дію (надає користувачу) не до конкретного об’єкту, а до всієї множини, що є необхідним в певних ситуаціях (наприклад, відображення списку всіх викладачів за певним критерієм).

\paragraph{HEAD}

Аналогічний GET, за винятком того, що у відповіді сервера відсутнє тіло. Це може бути необхідно для отримання мета-інформації.

\paragraph{POST}
\addCodeAsImg{\input{uml/CreateOperation}}{Виконання запиту на створення з аутентифікацією}{fig:CreateOperation}

Передає дані (наприклад, з форми на веб-сторінці) заданому ресурсу. При цьому передані дані включаються в тіло запиту. На відміну від методу GET, метод POST не є ідемпотентним, тобто багатократне повторення одних і тих же запитів POST може повертати різні результати (рис.~\ref{fig:CreateOperation}).

На першому етапі відбувається перевірка доступу користувача это створення об’єкту цього типу (авторизація), відповідно до прав доступу (рис.~\ref{fig:ApiAccess}).

\paragraph{PUT}
\addCodeAsImg{\input{uml/UpdateOperation}}{Виконання запиту на модифікацію існуючого об’єкту}{fig:UpdateOperation}

Завантажує вказаний ресурс на сервер. В розроблюваній системі використовується для редагування існуючих даних (рис.~\ref{fig:UpdateOperation}). 

В процесі виконання, спочатку з бази даних силами ORM вибирається конкретний об’єкт, в нього вносяться зміни, після чого він записується до сховища на заміну попередньої версії.

\paragraph{PATCH}

Завантажує частину ресурсу на сервер. При розробці необхідності у використанні не знайдено.

\paragraph{DELETE}
\addCodeAsImg{\input{uml/DeleteOperation}}{Виконання запиту на видалення об’єкту}{fig:DeleteOperation}

Видаляє вказаний ресурс.
Слід звернути увагу, що в процесі виконання запиту на видалення об’єкту в системі, видалення як такого не відбувається. Замість цього в окреме поле таблиці вноситься інформація про час виконання цієї процедури (рис.~\ref{fig:DeleteOperation}).

Такий спосіб реалізації дозволяє з однієї сторони приховати дані, відмічені як видалені від подальшого використання, а з іншої — зберегти їх там, де вони вже використовуються. В іншому випадку, у зв’язку з реляційністю бази потрібно було б вирішувати дилему — або проводити циклічне видалення для збереження цілісності даних, втрачаючи всі об’єкти, що посилаються на той, що видаляється; або ускладнювати структури даних, що потенційно призведе до дублювання даних.

\subsubsection{Публічне API}
\addimg{QRcode.png}{0.25}{Приклад QR-коду з посиланням}{fig:QRcode}

В процесі проектування створено структуру роутів, котра може використовуватися сторонніми сервісами, у тому числі — і без авторизації в системі, що дозволяє отримувати інформацію про розклади власними силами для подальшого використання тим чи іншим чином. 

Також було проаналізовано перспективи при використанні QR-кодів (рис.~\ref{fig:QRcode}) з метою супроводження традиційного паперового розкладу (та інших документів), що публікується на стендах.

Хоча термін «QR code» є зареєстрованим товарним знаком японської корпорації «DENSO Corporation», їх використання не обкладається ніякими ліцензійними відрахуваннями, коди описані та опубліковані як стандарти ISO \cite{воронкін2014можливості}. Основна перевага QR-коду – легке розпізнавання скануючим обладнанням (за допомогою мобільного телефону, планшета або ноутбука з камерою, на яких встановлена програма для зчитування кодів, тощо).

Одним з способів використання QR-кодів в навчальному процесі, крім запропонованих (зокрема, задля забезпечення швидкого доступу до навчально-методичного забезпечення, довідкової літератури, веб-сервісів навчального закладу) \cite[146]{воронкін2014можливості},  можна назвати надання доступу до електронної версії розкладу.
