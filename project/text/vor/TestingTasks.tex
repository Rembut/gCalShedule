\subsubsection{Задачі контролю якості}

Модульне тестування, або юніт-тестування -- процес в програмуванні, що дозволяє перевірити на коректність окремі модулі вихідного коду програми~\cite{бородіна2018selenium}.

Ідея полягає в тому, щоб писати тести для кожної нетривіальною функції або методу. Це дозволяє досить швидко перевірити, чи не призвело чергову зміну коду до регресії, тобто до появи помилок в уже покритих тестами місцях програми, а також полегшує виявлення і усунення таких помилок.

\subparagraph{Переваги модульного тестування}

Мета модульного тестування~--- ізолювати окремі частини програми і показати, що окремо ці частини працездатні.

\subparagraph{Заохочення змін}

Модульне тестування пізніше дозволяє програмістам проводити рефакторинг, будучи впевненими, що модуль як і раніше працює коректно (регресійні тестування). Це заохочує програмістів до змін коду, оскільки досить легко перевірити, що код працює і після змін.

\subparagraph{Спрощення інтеграції}
Модульне тестування допомагає усунути сумніви з приводу окремих модулів і може бути використано для підходу до тестування «знизу вгору»: спочатку тестуються окремі частини програми, потім програма в цілому.

\subparagraph{Документування коду}

Модульні тести можна розглядати як <<живий документ>> для тестованого класу. Клієнти, які не знають, як використовувати даний клас, можуть використовувати юніт-тест в якості прикладу.

\subparagraph{Відділення інтерфейсу від реалізації}

Оскільки деякі класи можуть використовувати інші класи, тестування окремого класу часто поширюється на пов'язані з ним. Наприклад, клас користується базою даних; в ході написання тесту програміст виявляє, що тесту доводиться взаємодіяти з базою. Це помилка, оскільки тест не повинен виходити за кордон класу. В результаті розробник абстрагується від з'єднання з базою даних і реалізує цей інтерфейс, використовуючи свій власний mock-об'єкт. Це призводить до менш пов'язаному коду, мінімізуючи залежності в системі.

\subparagraph{Обмеження}

Як і будь-яка технологія тестування, модульне тестування не дозволяє відловити всі помилки програми. Справді, це випливає з практичної неможливості трасування всіх можливих шляхів виконання програми, за винятком найпростіших випадків \cite{бородіна2018selenium}. Крім того, відбувається тестування кожного з модулів окремо. Це означає, що помилки інтеграції, системного рівня, функцій, виконуваних в декількох модулях, не будуть визначені. Крім того, дана технологія марна для проведення тестів на продуктивність. Таким чином, модульне тестування більш ефективно при використанні в поєднанні з іншими методиками тестування.

\subsubsection{Бібліотеки Jest та Enzyme}

Jest~--- це програма для запуску тестів, розроблена Facebook, створена на основі функціонального рішення для модульного тестування~\cite{9781680506464}.

Основні переваги Jest:
\begin{enumerate}
    \item дуже швидкий;
    \item тестування знімками;
    \item інтерактивний режим відстеження, який запускає тести тільки тих компонентів, які зазнали змін;
    \item корисні повідомлення про помилки;
    \item проста конфігурація;
    \item mock-об'єкти і spy-об'єкти;
    \item звіт про покриття всього однієї параметром командного рядка;
    \item неможливо написати неявні помилкові твердження, такі як $expect(foo).to.be.a.function$ замість $expect(foo). to.be.a( 'function')$ в Chai, тому що це природно писати так (правильно): $expect(foo).to.be.true.$
\end{enumerate}

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Jest.tex}}{Тестування обробника подій компонента вибору занять}{fig:Jest}

На рис.~\ref{fig:Jest} ми тестуємо обробник подій React-компоненту вибору заянть за допомогою mock-функції бібліотки Jest.

Enzyme є утилітою тестування JavaScript для React, що полегшує тестування компонентів React. Завдяки їй можна маніпулювати, і переміщати вихідні дані React-компонентів.

\paragraph{Shallow rendering}

Відображає тільки сам компонент, без дочірніх компонентів. Тому, якщо щось зміните в дочірньому компоненті, то це не змінить неглибокий висновок вашого компонента. І навіть баг, що знаходиться у вашому дочірньому компоненті, не змінить результат тестування вашого компонента. До того ж, для цього не потрібно DOM.

Перші утиліти для роботи з shallow rendering, статичної отрисовкой розмітки або отрисовкой DOM.
API, схожий на jQuery, для пошуку елементів, читання props тощо.
