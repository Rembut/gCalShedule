\subsubsection{Порівняння менеджерів стану}

\paragraph{Flux}

Flux-архітектура~--- архітектурний підхід або набір шаблонів програмування для побудови призначеного для користувача інтерфейсу веб-додатків, що поєднується з реактивним програмуванням і побудований на односпрямованих потоках даних.

Згідно із задумом творців і незважаючи на те, що Facebook надав реалізацію Flux на додаток до React, Flux не є ще одним веб-фреймворком, а є архітектурним рішенням~\cite{petrenko2015порівняння}.

Основною відмінною рисою Flux є одностороння спрямованість передачі даних між компонентами Flux-архітектури. Архітектура накладає обмеження на потік даних, зокрема, виключаючи можливість поновлення стану компонентів самими собою. Такий підхід робить потік даних передбачуваним і дозволяє легше простежити причини можливих помилок в програмному забезпеченні.

У мінімальному варіанті Flux-архітектура може містити три шари, які взаємодіють один по одному:

\begin{enumerate}
    \item actions (дії);
    \item stores (сховища);
    \item views (подання).
\end{enumerate}

Хоча зазвичай між діями і сховищами додають Dispatcher (диспетчер).

В першу чергу Flux працює з інформаційною архітектурою, яка потім відбивається в архітектурі програмного забезпечення, тому рівень уявлень слабо зачеплений з іншими рівнями системи.

\subparagraph{Дії}
Дії (англ. Actions)~--- вираз подій (часто для дій використовуються просто імена - рядки, що містять деяке «дієслово»). Диспатчери передають дії нижчого компонентів (сховищ) по одному. Нова дія не передається поки попереднє повністю не оброблено компонентами. Дії через роботу джерела дії, наприклад, користувача, надходять асинхронно, але їх диспетчеризація явлется синхронним процесом. Крім імені (англ. Name), дії можуть мати корисне навантаження (англ. Payload), що містить пов'язані з дією дані.

\subparagraph{Диспетчер}
Диспетчер (англ. Dispatcher) призначений для передачі дій сховищ. У спрощеному варіанті диспетчер може взагалі не виділятися, як єдиний на весь додаток. У диспетчері сховища реєструють свої функції зворотного виклику (callback) і залежності між сховищами.

\subparagraph{Сховища}
Сховище (англ. Store) є місцем, де зосереджено стан (англ. State) додатку. Інші компоненти, згідно Flux, не мають значного (з точки зору архітектури) стану. Зміна стану сховища відбувається строго на основі даних дії і старого стану сховища.

\subparagraph{Вид}
Вид (англ. View)~--- компонент, звичайно відповідає за видачу інформації користувачеві. У Flux-архітектурі, яка може технічно не торкатися внутрішнього облаштування уявлень взагалі, це - кінцева точка потоків даних. Для інформаційної архітектури важливо тільки, що дані потрапляють в систему (тобто, назад в сховища) тільки через дії.

\paragraph{Redux}

Redux~--- це інструмент управління як станом даних, так і станом інтерфейсу в JavaScript-додатках. Він підходить для односторінкових додатків, в яких управління станом може з часом стає складним. Redux не пов'язаний з якимось певним фреймворком, і хоча розроблявся для React, може використовуватися з Angular або jQuery.

У React не рекомендується реалізовувати пряму взаємодію компонент-компонент. Це вважається поганою практикою, призводить до помилок і заплутаність коду. Redux пропонує зберігати все стан додатки в одному місці, званому «store» («сховище»). Компоненти «відправляють» зміну стану в сховище, а не безпосередньо до інших компонентів. Компоненти, які повинні бути в курсі цих змін, «підписуються» на сховище.

Сховище може розглядатися як «посередник» у всіх змінах стану в додатку. З Redux компоненти не зв'язуються один з одним безпосередньо, всі зміни повинні пройти через єдине джерело істини, через сховище.

C Redux всі компоненти отримують свої дані зі сховища. Також ясно, куди компонент повинен відправити інформацію про зміну стану - знову ж в сховище. Компонент тільки ініціює зміну і не піклується про інші компоненти, які повинні отримати цю зміну. Таким чином, Redux робить потік даних більш зрозумілим.

Загальна концепція використання сховищ для координації стану програми - це шаблон, відомий як Flux. Цей шаблон проектування доповнює односпрямований потік даних як в React.

\paragraph{MobX}

MobX~--- це бібліотека, яка робить управління станом додатку простим і масштабується, застосовуючи функціонально-реактивне програмування~\cite{mezzalira2018mobx}. 

React і Mobx разом~--- потужна комбінація. React видображає стан додатку, надаючи механізми для перекладу його в дерево відображення компонентів. MobX надає механізм зберігання та оновлення стану, який потім може використовувати React.

React + MobX предcтавляют оптимальне рішення загальних проблем розробки додатків~\cite{9781789344837}. React дає можливість оптимально відображати інтерфейс за допомогою Virtual DOM, що зменшує кількість дорогих мутацій оригінального DOM. MobX дозволяє синхронізувати стан між React-компонентами, використовуючи реактивну віртуальну залежність графічного стану, яке оновлюється лише коли це дійсно потрібно.

MobX додає можливість спостерігати за існуючими структурами даних, такими як об'єкти, масиви і екземпляри класів. Це досить просто зробити, обернувши необхідну властивість класу за допомогою декоратора $@observable$ (рис.~\ref{fig:Code10}).

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code10.tex}}{Приклад використання декоратора $@observable$}{fig:Code10}

Використання $@observable$ схоже на перетворення властивості об'єкта в клітинку електронної таблиці. Але на відміну від електронних таблиць ці властивості можуть бути не тільки примітивними значеннями, але також посиланнями, об'єктами і масивами.

Значеннями, що спостерігаються, можуть бути JS-примітиви, посилання, об'єкти, екземпляри класів, масиви і т.д. Якщо значенням є масив або об'єкт, при виведенні змінної буде повернутий $Observable Array$ або $Observable Object$ відповідно.

\subsubsection{Redux}

Redux~--- це інструмент управління як станом даних, так і станом інтерфейсу в JavaScript-додатках. Він підходить для односторінкових додатків, в яких управління станом з часом може ускладнюватися. Redux не пов'язаний з якимось певним фреймворком, і хоча розроблявся для React, може використовуватися з Angular або jQuery.

C Redux всі компоненти отримують свої дані зі сховища. Також зрозуміло, куди компонент повинен відправити інформацію про зміну стану~--- знову ж в сховище. Компонент тільки ініціює зміну і не піклується про інших компонентах, які повинні отримати цю зміну. Таким чином, Redux робить потік даних більш зрозумілим.

Загальна концепція використання сховищ для координації стану програми~--- це шаблон, відомий як Flux. Цей шаблон проектування доповнює односпрямований потік даних як в React.

Redux використовує тільки одне сховище для всього стану програми. Оскільки стан знаходиться в одному місці, його називає єдиним джерелом істини. Структура даних сховища повністю залежить від вас, але для реального застосування це, як правило, об'єкт з декількома рівнями укладення.

Такий підхід єдиного сховища є основною відмінністю між Redux і Flux з його численними сховищами~\cite{9781617294976}.

Згідно з документацією Redux, <<Єдиний спосіб змінити стан - передати action — об'єкт, що описує, що сталося>>. Це означає, що програма не може безпосередньо змінити стан. Замість цього, необхідно передати $action$, щоб висловити намір змінити стан в сховищі (рис.~\ref{fig:ReactReduxCommunicate}).

\subsubsection{Обробка побічних ефектів}

\paragraph{Порівняння бібліотек}

Redux-thunk і Redux-saga~--- обидві бібліотеки для обробки побічних ефектів при розробці з використанням бібліотеки Redux~\cite{mezzalira2018mobx}. Проміжні обробники Redux - це код, який перехоплює дії, що надходять у сховище, за допомогою методу $dispatch ()$.


Крім диспетчеризації стандартних дій, Redux-Thunk middleware дозволяє розсилати спеціальні функції, які називаються $thunks$.

Thunks (в Redux) зазвичай мають структуру, представлену на рис.~\ref{fig:Code11}.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code11.tex}}{Структура Thunks в Redux}{fig:Code11}

Тобто thunk - це функція, яка (необов'язково) приймає деякі параметри і повертає іншу функцію. Внутрішня функція приймає функцію диспетчеризації та функцію $getState$ - обидві з них будуть поставлятися за допомогою бібліотеки Redux-Thunk.

Redux-Saga middleware дозволяє висловлювати складну логіку застосування як чисті функції, що називаються сагами. Чисті функції бажані з точки зору тестування, тому що вони передбачувані і повторювані, що робить їх порівняно легкими для перевірки~\cite{hung2018architectural}.

Саги реалізуються за допомогою спеціальних функцій, званих функціями генератора. Це нова функція ES6 JavaScript. Усередині функції-генератора є ключове слово $yield$ з синтаксисом, схожим на $return$. Відмінність в тому, що функція (у тому числі функція-генератор) може повернути значення тільки один раз, але віддати значення функція-генератор може скільки завгодно раз. Вираз $yield$ призупиняє виконання генератора, так що його можна пізніше відновити.

Функція генератора представлена на рис.~\ref{fig:Code12}. Зверніть увагу на зірочку після ключового слова функції.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code12.tex}}{Структура функції генератора}{fig:Code12}

\paragraph{Redux Thunk}

TODO