\subsubsection{Бібліотеки JS}

\paragraph{React}

React Js - це JavaScript бібліотека для побудови призначених для користувача інтерфейсів, розроблений програмістами Facebook. Він призначений для створення інтерфейсів. Тут важливо враховувати, що React - це тільки система відображення, на відміну від повноцінного фреймворка, наприклад, Angular~\cite{fedosejev2015react}.

React надає розробникам мовні шаблони і функції зворотного зв'язку, що дозволяють відображати HTML. Зв'язки HTML-JS називаються компонентами, які запам'ятовують свій внутрішній стан. У React використовується компонентний підхід, що дозволяє обходиться без шаблонів, моделей, контролерів тощо~\cite{sagarganatra2018}.

Результат роботи в React завжди буде залежати від складових його компонентів. Особливістю цього фреймворка є JSX (поєднання Javascript і HTML). Що дозволяє бачити зміни, що відбуваються в одному місці. Після обробки всіх процесів в результаті ми отримуємо чистий JS~\cite{js.next:ecmascript6}.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code1.tex}}{Приклад React компоненту з використанням синтаксису JSX}{fig:Code1}

React може використовуватися практично в будь-якому проекті і підійде як для великого, так і малого бізнесу. Серед розробників існує чимало суперечок з приводу використання цього продукту. Як і будь-який інструмент React має свої переваги і недоліки~\cite{caspers2017react}.

Під час роботи компонент проходить через ряд етапів життєвого циклу. На кожному з етапів виконується певна функція, у якій ми можемо визначити якісь дії:

\begin{enumerate}
    \item $constructor(props):$ конструктор, у якому відбувається початкова ініціалізація компоненту;
    \item $componentWillMount():$ викликається безпосередньо перед рендерингом компоненту;
    \item $render():$ рендеринг компоненту;
    \item $componentDidMount():$ викликається після рендерингу компонента. Тут можна виконувати запити до API;
    \item $componentWillUnmount():$ викликається перед видаленням компоненту з DOM.
\end{enumerate}

Окрім цих головних етапів чи подій життєвого циклу також мається ще ряд функцій, що викликаються при оновленні стану після рендерингу компоненту:

\begin{enumerate}
    \item $shouldComponentUpdate(nextProps, nextState):$ викликається кожного разу при оновленні об'єкту props або state. У якості параметра передаються новий об'єкт props та state. Ця функція винна повертати true (треба робити оновлення) або false (ігнорувати оновлення). За замовчуванням повертається true. Але якщо функція буде повертати false, то тим самим ми відключимо оновлення компонента, а наступні функції не будуть спрацьовувати.
    \item $componentWillUpdate (nextProps, nextState):$ викликається перед оновленням компонента (якщо shouldComponentUpdate повертає true)
    \item $render ():$ рендеринг компонента (якщо shouldComponentUpdate повертає true)
    \item $componentDidUpdate (prevProps, prevState):$ викликається відразу після оновлення компонента (якщо shouldComponentUpdate повертає true). Як параметри передаються старі значення об'єктів props і state.
\end{enumerate}

І окремо варто відзначити функцію $componentWillReceiveProps(nextProps),$ яка викликається при оновленні об'єкта props. Нові значення цього об'єкта передаються в функції як параметр. Як правило, в цій функції встановлюються ті властивості компонента, в тому числі з this.state, які залежать від значень з props.

Переваги:
\begin{enumerate}
    \item Легко уявити кінцевий результат. Подивившись на вихідний код, можна уявити, як буде відображено потрібний компонент. Знаючи стан коду, можна з точністю визначити результат відтворення. Це важливо при роботі в команді, так як не потрібно відстежувати весь процес розробки проекту.
    \item Простота використання. На React просто писати код, і на ньому ж легко тестувати продукт.
    \item Зв'язка JavaScript і HTML в JSX дозволяє швидше і простіше працювати з компонентами. Об'єднання функціональної частини з розміткою і їх упаковка в окремий компонент зробить код краще.
    \item Візуалізація на сервері. React можна візуалізувати на сервері ще до знайомства сайту з його потенційними клієнтами.
    \item Створення інтерфейсу (UI) відбувається на основі окремих компонентів. Це майбутнє веб-розробки.
    
\end{enumerate}

Недоліки:
\begin{enumerate}
    \item Використання глобальних станів. За рахунок компонентного підходу іноді глобальні стану доводиться прокидати крізь 10 компонентів, а це трата часу на всього лише одну константу. 
    \item Деякі програми не підтримують React. Щоб уникнути цієї ситуації застосовують додаткові плагіни і завантажують розширення. Однак, через велику вагу, в React їх краще використовувати по мінімуму. 
    \item React займає досить багато місця на диску через великий розмір в порівнянні з подібним за можливостями йому VueJS (детальніше в пункті~\ref{subs:vue}).
\end{enumerate}

\paragraph{LESS}

LESS - це препроцесор CSS, що дозволяє використовувати змінні, функції, цикли і інші технології для спрощення роботи зі стилями. Препроцесор в даному випадку означає, що ми маємо справу з динамічним мовою стилів, який перетворюється в CSS. Таким чином, на виході отримуємо стандартний стильовий файл~\cite{9781782160663}.

LESS надає можливості використовувати підходи і прийоми, які в CSS на даний момент відсутні, але характерні для мов програмування. Наприклад, ті ж змінні дозволяють задати будь-яке значення, а потім використовувати його багато разів, підставляючи лише ім'я змінної (рис.~\ref{fig:Code21}, рис.~\ref{fig:Code22}).

Характерною особливістю LESS став синтаксис заснований на CSS. Це відразу ж знизило поріг входження і вивчення нової технології, до того ж не виникає ніяких проблем з редакторами коду, вони прекрасно підтримують підсвічування синтаксису. Надалі LESS зробив свій вплив на препроцесор SASS, в якому з'явився новий схожий синтаксис. Але в цілому, питання, хто на кого вплинув відкритий, тому що багато корисних речей були запозичені друг у друга. Так що зараз і LESS і SASS дуже схожі, відрізняючись лише в деталях.

LESS дозволяє використовувати змінні. Ім'я змінної починаються з символу @. В якості знака присвоювання використовується двокрапка (:).

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code21.tex}}{Приклад використання змінних у LESS}{fig:Code21}

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code22.tex}}{Результуючий CSS після компіляції LESS}{fig:Code22}

Домішки дозволяють включати цілий набір властивостей з одного набору правил в інший шляхом включення імені класу в якості одного з властивостей іншого класу(рис.~\ref{fig:Code31}, рис.~\ref{fig:Code32}). Таку поведінку можна розглядати як різновид констант або змінних. Вони також можуть вести себе подібно до функцій, приймаючи аргументи. У чистому CSS дубльований код повинен бути повторений в декількох місцях - домішки роблять код чистіше, зрозуміліше і спрощують його написання.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code31.tex}}{Використання домішок LESS в коді}{fig:Code31}

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code32.tex}}{CSS після компіляції коду з домішками LESS}{fig:Code32}

LESS дає можливість вкладати визначення замість або разом з каскадуванням(рис.~\ref{fig:Code41}, рис.~\ref{fig:Code42}). Нехай, наприклад, у нас є такий CSS: CSS підтримує логічне каскадування, але один блок коду в інший вкладений бути не може. Less дозволяє вкласти один селектор в інший. Це робить спадкування більш ясним і вкорочує таблиці стилів.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code41.tex}}{Використання вкладених правил LESS}{fig:Code41}

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code42.tex}}{Вкладені правила після компіляції}{fig:Code42}

LESS дозволяє використовувати операції та функції. Завдяки операціям можна додавати, віднімати, ділити і множити значення властивостей і кольорів, що можна використовувати для створення складних відносин між властивостями.

\paragraph{CSS Modules}

CSS1 був створений в 1996 році, щоб відокремити вміст документа від його оформлення. Головне слово тут документ. Таблиці стилів були крихітними за сучасними мірками, і будь-які складності підтримки з лишком компенсувалися перевагами роздільного підходу. Сьогодні ми рідко замислюємося про контент в контексті документа. У сучасному інтернеті переважають високодинамічні сторінки з величезною кількістю елементів графічного оформлення. Сьогоднішні таблиці стилів мають тисячі рядків і містять сотні селектор.

Створення, підтримка та масштабування CSS досить серйозний виклик для команди розробників. Для виконання цього завдання необхідно в рівній мірі добре розбиратися в специфікації мови, вміти користуватися сучасними інструментами і фреймворками, а також чітко розуміти структуру документа.

Більшість розробників прекрасно інформовані про неприємні наслідки неакуратної роботи з глобальною областю видимості в JavaScript, але чомусь абсолютно ігнорують подібну ситуацію з CSS.

Незалежно від того, якими фреймворками, препроцесор або іншими інструментами ви користуєтеся, CSS завжди буде виконуватися в одному глобальному контексті. Через це селектори можуть перетинатися або накладатися: це призводить до небажаного спадкоємства, що потребує чергового втручання в і без того хитку систему.

У спробі уникнути негативних наслідків небажаного успадкування розробники починають створювати селектори, що складаються з величезної кількості умов (рис.~\ref{fig:Code8}), зі стилями, які виконують одну конкретну задачу. Зазвичай з цього не виходить нічого хорошого.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code8.tex}}{Приклад невдалого використання селекторів css}{fig:Code8}

Такий підхід має ряд значних недоліків:
\begin{enumerate}
    \item Він вбиває продуктивність. Приклад зображений на рисунку, вимагає від браузера знаходження семи об'єктів в DOM перш, ніж почнеться рендеринг. Це досить незначно, якщо кількість таких селекторів невелика, але якщо вони лежать в основі вашого підходу, ви збільшуєте час коректного відображення сторінки на кілька секунд.
    \item Байти все ще мають значення, особливо, якщо мова йде про мобільні пристрої з обмеженою швидкістю з'єднання.
    \item Він практично виключає повторне використання. Замість того щоб працювати з каскадуванням, ви боретеся з ним, тим самим знижуючи можливість повторного використання і дублювання.
\end{enumerate}

Препроцесори одна з кращих знахідок останнього десятиліття. Вони цінна частина архітектури, але не вирішують усіх проблем притаманних CSS. Препроцесори мають кілька очевидних переваг:

Налагодження і підтримка коду значно спрощується завдяки імпорту, значенням і домішкам. Рефакторинг стає менш складним і більш передбачуваним, так як модулі специфічних стилів вміщені в їх власних відповідних файлах.

Незважаючи на всі переваги препроцесорів, вони не вирішують головного завдання. Препроцесори використовують import для підключення модулів, але в підсумку всі вони виконуються в загальній області видимості.

\subparagraph{Модульний CSS}

Цей підхід дозволяє створювати селектори, які не призведуть до небажаного спадкоємства, без складної загальної конвенції.

Створення модульного CSS нічим не відрізняється від створення будь-якого іншого файлу стилів. Ви можете називати класи так, як вам подобається, без проблем із загальною областю видимості. Синтаксис залишається незмінним, тому всі розроблені раніше рішення будуть працювати так, як ви очікуєте.

\paragraph{Ant Design}

Строго кажучи, Ant Design - це повноцінна дизайн-система. Зі своїми принципами, стайлгайдами і бібліотекою компонентів, про яку й піде мова в цій статті. Проект підтримується розробниками з Alibaba Group. Ті ж розробники підтримують і dva - фреймворк на основі популярного стека React, Redux, React-Router, активно використовується в проектах Alibaba. Сам Ant Design написаний на TypeScript, стилізований за допомогою Less і портований на Angular і Vue.

\subparagraph{Вбудована пагінація}
За замовчуванням - клієнтська. Але можна без проблем написати свою. Тобто реалізувати серверну пагінацію не складе труднощів.

\subparagraph{Фільтрація і сортування}
З коробки доступна фільтрація по випадаючому селектору з опціями. Описувати функції сортування і фільтрації потрібно власноруч. За замовчуванням таблиці не вміють фільтрувати записи по введеному рядку. Але можна написати власний фільтр, що докладно описано в документації. Потрібно визнати, процес досить не простий, але можливостей багато.

\subparagraph{Вибір рядків}
Якщо вам необхідно забезпечити вибір конкретних рядків таблиці для подальших дій з боку користувача, таблиці Ant Design надають для цього досить гнучкий API.

\subparagraph{Вкладеність}
Іноді буває необхідно зробити деякі рядки таблиці можливість розгортатися, щоб приховати додаткову інформацію. Таблиці Ant Design вміють це з коробки.

\subparagraph{Об'єднання осередків}
Об'єднання осередків в заголовку і в рядках відрізняються, але в обох випадках потрібно заздалегідь знати, які саме осередки необхідно об'єднати, і вказувати їх явно. Це сильно ускладнює обробку динамічних даних, але в принципі не робить її неможливою.

\subparagraph{Редаговані осередки}
API у таблиць в загальному досить гнучке і не накладає багато обмежень на способи рендерінгу осередків. 

\subparagraph{Фіксація колонок і заголовка}
Мабуть, найбільш затребувана для відтворення великих обсягів даних функція. Можна зафіксувати як ліву, так і праву колонки, заголовок таблиці, і навіть все разом.

\paragraph{Redux}

У міру того як вимоги до односторінковим JavaScript додатків стають все більш високими, ми змушені керувати все більшою кількістю станів (State) за допомогою JavaScript. Ці стани можуть включати в себе відповіді сервера, кешування даних, а також дані, створені локально, але ще не збережені на сервері. Це також відноситься до UI-станів, таким як активний маршрут (route), виділений таб або нумерація сторінок і т.д.

Управляти динамічними станами досить складно. Може виникнути ситуація у якій оновлення моделей може відбуватися в функціях великої глибини вкладеності. У такому випадку важко підсліджувати на якому саме етапі відбувається зміна моделі та вносити зміни до цієї структури~\cite{robinwieruch2018}. Коли система стає непрозорою і недетермінованої, важко виявити помилки або додавати нову функціональність.

Це досить проблематично, беручи до уваги нові вимоги, що стають звичними для фронтенд-розробки, такі як: обробка оптимістичних оновлень (optimistic updates), рендерінг на сервері, вилучення даних перед виконанням переходу на сторінку і так далі.  Ця складність виникає через змішування двох концепцій, які дуже нелегкі для розуміння: зміни (mutation) і асинхронність (asynchronicity). Обидві ці концепції можуть бути прекрасними окремо, але разом вони перетворюються в бардак. Бібліотеки, аналогічні React, намагаються вирішити цю проблему на рівні відображення, видаляючи асинхронність і пряме маніпулювання DOM. Проте, React залишає управління станом даних за вами. І тут в справу вступає Redux.
Йдучи по слідах Flux, CQRS і Event Sourcing, Redux намагається зробити зміни стану передбачуваними, шляхом введення деяких обмежень на те, як і коли можуть відбутися оновлення. Redux може бути описаний трьома фундаментальними принципами~\cite{davidgeary2019}.

\subparagraph{Єдине джерело правди}

Стан всього вашого застосування збережено в дереві об'єктів всередині одного сховища.

Це полегшує створення універсальних програм. Стан на сервері може бути серіалізовано і відправлено на клієнт без додаткових зусиль. Це спрощує налагодження програми, коли ми маємо справу з єдиним деревом стану (рис.~\ref{fig:Code5}). Ви також можете зберігати стан вашого застосування для прискорення процесу розробки. І з єдиним деревом стану ви отримуєте функціональність типу $Undo / Redo$ з коробки.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code5.tex}}{Приклад сховища у Redux}{fig:Code5}

\subparagraph{Стан тільки для читання}

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code6.tex}}{Приклад відправлення дії у редюсер}{fig:Code6}

Єдиний спосіб змінити стан -- це застосувати дію (рис.~\ref{fig:Code6}) -- об'єкт, який описує, що трапиться. 

Це гарантує, що відображення або функції, що реагують на події мережі (network callbacks), ніколи не змінять стан безпосередньо. Оскільки всі зміни централізовані і застосовуються послідовно в строгому порядку, тому немає необхідності стежити за <<гонкою станів>>. Дії -- це всього лише прості об'єкти, тому вони можуть бути залоговані, серіалізовані, збережені і потім відтворені для налагодження або тестування.

\subparagraph{Мутації реалізовані як чисті функції}

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code7.tex}}{Приклад реалізації редюсера у Redux}{fig:Code7}

Для визначення того, як дерево стану буде трансформовано діями, ви пишете чисті редюсери.
Редюсери -- це просто чисті функції (рис.~\ref{fig:Code7}), які беруть попередній стан і дію і повертають новий стан. Не забувайте повертати новий об'єкт стану замість того, щоб змінювати попереднє. Ви можете почати з одного редюсера, але в подальшому, коли ваш додаток розростеться, ви можете розділити його на більш дрібні редюсери, які керують окремими частинами дерева стану. Оскільки редюсери -- це просто функції, ви можете контролювати порядок, в якому вони викликаються, відправляти додаткові дані або навіть писати редюсери для загальних завдань для подальшого їх перевикористання, наприклад, для пагінації.

\paragraph{Redux Thunk}

За замовчуванням дії в Redux відправляються синхронно, що є проблемою для будь-якої нетривіальної програми, яка потребує в зв'язку з зовнішнім API або виконує побічні ефекти. На щастя, Redux дозволяє використання проміжних обробників , які знаходиться між відправленними діями та діями, що досягають редукторів. Є дві дуже популярні бібліотеки проміжного програмного забезпечення, які допускають побічні ефекти та асинхронні дії: Redux Thunk та Redux Saga.

Redux Thunk -- це проміжне програмне забезпечення, яке дозволяє викликати творців дій, які повертають функцію замість об'єкта дії. Ця функція отримує метод розсилки сховища, який потім використовується для відправлення регулярних синхронних дій всередині тіла функції після завершення асинхронних операцій.

Найбільш поширеним випадком використання для Redux Thunk є асинхронне спілкування з зовнішнім API для отримання або збереження даних. Redux Thunk дозволяє легко розсилати дії, які слідують за життєвим циклом запиту до зовнішнього API.

Наприклад, з урахуванням загального прикладу програми todo, створення нового елемента задачі зазвичай передбачає першу відправлення дії, щоб вказати, що створення елемента todo почалося, тоді, якщо елемент todo успішно створено і повернуто зовнішнім сервером, відбувається відправлення іншої дії з новим елементом завдання. У випадку, якщо є помилка, і завдання не може бути збережено на сервері, замість цього може бути надіслано дію з помилкою.

\addCodeAsImg{\lstinputlisting[numbers=left]{code/Code9.tex}}{Використання бібліотеки сonnected-react-router}{fig:Code9}


\paragraph{Connected React Router}

Connected React Router -- бібліотека яка дозволяє зберігати весь стан  URL в сховище redux. Connected React Router створює зв'язок між  Redux-додатком і React Router і дозволяє їх синхронізувати.

\paragraph{React Router}

У React є своя система маршрутизація, яка дозволяє зіставляти запити до додатка з певними компонентами. Ключовою ланкою в роботі маршрутизації є модуль react-router, який містить основний функціонал по роботі з маршрутизацією.

React -- це не фреймворк, а бібліотека, і, отже, він не призначений для вирішення всіх потреб програми. Він відмінно працює в створенні компонентів і надає систему для управління станом, але створення складного SPA потребує використання додаткових модулів.

Роутинг -- це маршрутизація: вхідний URL розбирається спеціальним чином і по його результату виконується певний код. Маршрутизація визначає, як додаток відповідає на клієнтський запит до конкретної адреси (URI).

React Router надає три компонента для початку роботи:

\begin{enumerate}
    \item Router і Route: Використовуються для декларативного опису карти маршрутів додатку;
    \item Link: Використовується для створення посилань з заданим href. Це не єдиний спосіб навігації, але все ж основний;
\end{enumerate}

\paragraph{Axios}

Технологія Ajax дуже популярна і використовується на багатьох сайтах. У мережі можна знайти різні реалізації функцій для роботи з Ajax на чистому нативном JavaScript, але з такими функціями не дуже зручно працювати, і, найчастіше, вони мають проблеми з кросбраузерністю, тому, як правило, для роботи з Ajax-запитами використовуються різні фреймворки і бібліотеки.

Найпростішим і популярним рішенням є використання бібліотеки jQuery і її методу $ajax()$, але якщо jQuery використовується тільки для відправки Ajax-запитів, а решта функціоналу бібліотеки просто «висить баластом», то використання jQuery в такому випадку буде надлишковим. Для цього можна вибрати профільну бібліотеку, яка буде в рази менше, що буде сприяти швидкодії роботи сайту.

Axios -- це кросбраузерна легковага JS-бібліотека для роботи з HTTP-запитами, побудована на $Promise API$. Axios може працювати як з NodeJS, так і з браузерним JavaScript; це дуже зручно, якщо потрібно просто підключити скрипт до веб-сторінки, не піднімаючи при цьому NodeJS.
