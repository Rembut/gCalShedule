\section{ПРОЕКТУВАННЯ FRONT-END ЧАСТИНИ}

\subsection{Аналіз існуючих бібліотек для розробки SPA}

На сьогодні, одними з росповсюджених фреймворків для розробки SPA (single page applications) є React, Angular та Vue (рис.~\ref{fig:ReactAngularVue}).

\addimg{ReactAngularVue.png}{0.35}{React, Angular та Vue}{fig:ReactAngularVue}

Angular - Javascript-фреймворк, створений на основі TypeScript. Розроблений і підтримуваний компанією Google, він описується як JavaScript MVW-фреймворк. На даний момент останньою версією є 4. Фреймворк Angular використовується такими компаніями, як Google, Wix, weather.com, healthcare.gov і Forbes.

Vue - ще один JS-фреймворк. Творці Vue описують його як «інтуїтивно зрозумілий та швидкий, призначений для створення інтерактивних інтерфейсів». Вперше він був представлений колишнім співробітником компанії Google Еваном Ю (Evan You) в лютому 2014 року. На даний момент фреймворк використовується такими компаніями, як Alibaba, Baidu, Expedia, Nintendo, GitLab.

\subsection{React}

При розробці мобільного додатку використано фреймворк React Native, в основі якого знаходиться бібліотека React, призначена для створення користувацьких інтерфейсів. На відміну від React, призначеного для розробки односторінкових веб-додатків, React Native спрямований на мобільні платформи.

React — відкрита JavaScript бібліотека для створення інтерфейсів користувача, яка покликана вирішувати проблеми часткового оновлення вмісту веб-сторінки, з якими стикаються в розробці односторінкових застосунків. React використовують Facrbook, Airbnb, Uber, Netflix, Twitter, Pinterest, Reddit, Udemy, Wix, Paypal, Imgur, Feedly, Stripe, Tumblr, Walmart та інші.

React дозволяє розробникам створювати великі веб-додатки, які використовують дані, котрі змінюються з часом, без перезавантаження сторінки. React обробляє тільки користувацький інтерфейс у застосунках. Це відповідає видові у шаблоні модель-вид-контролер (MVC) і може бути використане у поєднанні з іншими JavaScript бібліотеками або в великих фреймворках MVC, таких як AngularJS. Він також може бути використаний з React на основі надбудов, щоб піклуватися про частини без користувацького інтерфейсу побудови веб-застосунків.

React підтримує віртуальний DOM, а не покладається виключно на DOM браузера. Це дозволяє бібліотеці визначити, які частини DOM змінилися, порівняно зі збереженою версією віртуального DOM, і таким чином визначити, як найефективніше оновити DOM браузера. Як бібліотека інтерфейсу користувача React часто використовується разом з іншими бібліотеками, такими як Redux, проте у його використанні при розробці проекту не було необхідності.

React надає розробникам безліч методів, які викликаються під час життєвого циклу компонента (рис.~\ref{fig:ReactReduxCommunicate}), вони дозволяють нам оновлювати UI і стан додатку. Коли необхідно використовувати кожен з них, що необхідно робити і в яких методах, а від чого краще відмовитися, є ключовим моментом до розуміння як працювати з React.

\addimg{ReactReduxCommunicate.png}{0.85}{Взаємодія Redux та React}{fig:ReactReduxCommunicate}

Конструктори є основною ООП — це спеціальна функція, яка буде викликатися щоразу, коли створюється новий об'єкт. Важливо викликати функцію super в випадках, коли наш клас розширює поведінку іншого класу, який має конструктор. Виконання цієї спеціальної функції буде викликати конструктор нашого батьківського класу і дозволяти йому проініціаліззувати себе. 
Конструктори —  це відмінне місце для ініціалізації компонента —  створення будь-яких полів (змінні, що починаються з this.).

Це також єдине місце де слід встановлювати стан безпосередньо перезаписуючи поле this.state. У всіх інших випадках необхідно використовувати this.setState.
За замовчуванням, всі компоненти будуть перемальовувати себе всякий раз, коли їх стан змінюється, змінюється контекст або вони приймають props від батьківського компонента. Якщо перерисовка компонента досить важка (наприклад генерація графіка), то у розробників є доступ до спеціальної функції, яка дозволяє контролювати цей процес.

\subsection{Проектування та прототипування front-end частини}

\subsubsection{Webpack}

При створенні сайту досить стандартною практикою є мати певний процес збірки на місці, щоб полегшити розробку і підготовку файлів до роботи.

Можливо використовувати Grunt або Gulp, побудувавши ланцюжки перетворень, які дадуть можливість подати код в один кінець ланцюжка і отримати мінімізовані CSS та JavaScript на іншому.

Подібні інструменти розробки досить популярні і корисні в наші дні. Проте, є й інший метод полегшення розробки — Webpack.

Webpack є так званим «збиральником модулів». Він приймає модулі JavaScript, аналізує їх залежності один від одного, а потім з'єднує їх найефективнішим способом, випускаючи у кінці лише один JavaScript файл. З Webpack, модулі не обмежені тільки файлами JavaScript. Завдяки частині loaders, Webpack розуміє, що модуль JavaScript може потребувати CSS файл, а цей CSS файл може потребувати зображення. Результат роботи Webpack буде містити тільки те, що потрібно у проекті.

\subsubsection{Babel}

Нажаль, при постійному розвитку мов програмування невід'ємною є ситуація, що реалізація часто відстає від специфікації. Більш того, різні реалізації по-різному відстають від специфікації. Написавши код, ми не можемо гарантувати, де він буде запускатися, а де - ні.

Виходячи з цього можна зробити висновок, що потрібно писати код, дотримуючись старих стандартів. На щастя, є інший шлях: ми можемо писати код з використанням всіх найновіших можливостей, але перед публікацією автоматично транслювати його (тобто переводити з одного виду в інший) в стару версію. 

Сама природа JS і його способи використання готують нас до того, що ніколи не настане моменту, коли у всіх користувачів буде остання версія інтерпретатору. Люди використовували і продовжать використовувати різні браузери і різні версії браузерів, різні версії Node.js і так далі. Використання нових синтаксичних конструкцій в такій ситуації практично неможливо. Запуск коду на платформі що не підтримує новий синтаксис призведе до синтаксичну помилку. 

Закономірним вирішенням цієї проблеми стала поява Babel - програми, яка бере вказаний код і повертає той же код, але транслювали в стару версію JS. Фактично, в сучасному світі Babel став невід'ємною частиною JS. Всі нові проекти так чи інакше розробляють з його використанням.

\subsubsection{Розробка компонентів}

В термінах React, всі частини-відображення іменуються компонентами. В роботі спроектована серія компонентів для різних частин системи та розроблено прототипи деяких з них. 

На рис.~\ref{fig:AdminPanelUserCreation} зображено компонент для створення адміністратором нового користувача системи. Слід наголосити, що кожен компонент є окремою частиною і тому можливий для використання у подальшому в інших системах при виконанні певних вимог (так зване «повторне використання»).

\addimg{AdminPanelUserCreation.png}{0.85}{Адміністративна панель (створення користувача)}{fig:AdminPanelUserCreation}

На приведеному вище зображенні натискання на кожну з кнопок призводить до виклику відповідного методу API шляхом надсилання певного HTTP запиту.

Перед доступом до адміністративної панелі (рис.~\ref{fig:AdminPanelUserManagement}) адміністратору необхідно авторизуватися у системі, в результаті чого буде створено і збережено силами його веб-браузеру JWT (підрозділ \ref{subsubsection:jwt}). Після цього, якщо він має відповідні права  (рис.~\ref{fig:ApiAccess}) та верифікація токену пройшла успішно (блок Auth на рис.~\ref{fig:CreateOperation}), йому буде відображена відповідна панель.

\addimg{AdminPanelUserManagement.png}{0.85}{Адміністративна панель (керування користувачами)}{fig:AdminPanelUserManagement}

Слід зауважити, що подібний процес перевірки відбувається при виконанні кожного запиту, крім тих, що не потребують авторизації (доступні для незареєстрованих користувачів, рис.~\ref{fig:ApiAccess}).

Перша прерогатива адміністратора системи — створення нових користувачів. При цьому відбувається вищеописана процедура, та реалізується процес, котрий детально зображено на діаграмі \ref{fig:AppSignUp}.

Певна частина об’єктів системи може вважатися більш-менш константною, це структура закладу вищої освіти (рис.~\ref{fig:AdminPanelFacultyManagement}), окремі словникові дані (зокрема, назви посад професорсько-викладацького складу та види занять).

\addimg{AdminPanelFacultyManagement.png}{0.85}{Адміністративна панель (керування факультетами)}{fig:AdminPanelFacultyManagement}

Окремо можна відзначити використання об’єктів часу (номера занять впродовж дня, рис.~\ref{fig:AdminPanelTimeManagement}).  В спроектованій системі одним з можливих шляхів доступу до розкладу є його експорт до сервісу Google Calendar в серію календарів. 

\addimg{AdminPanelTimeManagement.png}{0.85}{Адміністративна панель (керування часом)}{fig:AdminPanelTimeManagement}

В подальшому, потенційні користувачі можуть підписуватися на оновлення відповідних календарів (зокрема, груп та викладачів) для отримання актуальної інформації в довільний момент часу.

\subsection{Менеджери стану}

Redux — це інструмент управління як станом даних, так і станом інтерфейсу в JavaScript-додатках. Він підходить для односторінкових додатків, в яких управління станом може з часом стає складним. Redux не пов'язаний з якимось певним фреймворком, і хоча розроблявся для React, може використовуватися з Angular або jQuery.

C Redux всі компоненти отримують свої дані зі сховища. Також зрозуміло, куди компонент повинен відправити інформацію про зміну стану — знову ж в сховище. Компонент тільки ініціює зміну і не піклується про інших компонентах, які повинні отримати цю зміну. Таким чином, Redux робить потік даних більш зрозумілим.

Загальна концепція використання сховищ для координації стану програми — це шаблон, відомий як Flux. Цей шаблон проектування доповнює односпрямований потік даних як в React.

Redux використовує тільки одне сховище для всього стану програми. Оскільки стан знаходиться в одному місці, його називає єдиним джерелом істини. Структура даних сховища повністю залежить від вас, але для реального застосування це, як правило, об'єкт з декількома рівнями укладення.

Такий підхід єдиного сховища є основною відмінністю між Redux і Flux з його численними сховищами.

Згідно з документацією Redux, «Єдиний спосіб змінити стан - передати action — об'єкт, що описує, що сталося». Це означає, що програма не може безпосередньо змінити стан. Замість цього, необхідно передати «action», щоб висловити намір змінити стан в сховищі (рис.~\ref{fig:ReactReduxCommunicate}).
